From c1202bd4abb2cfdce2b4e60603b7d0c85eff0fb9 Mon Sep 17 00:00:00 2001
From: Janne Karhunen <Janne.Karhunen@gmail.com>
Date: Thu, 4 Sep 2025 12:31:00 +0300
Subject: [PATCH] qemu/q35: skip bogus sata controller init

There seems to be a bug in the QEMU where the PCI(0x2,0x0), aka VGA
for Q35, reports being a SATA controller. We detect the case and
skip such bogus sata controller init. This is a workaround, real
fix is to go in the qemu itself.

Signed-off-by: Janne Karhunen <Janne.Karhunen@gmail.com>
---
 .../Pci/SataControllerDxe/SataController.c    | 61 ++++++++++++++++++-
 1 file changed, 59 insertions(+), 2 deletions(-)

diff --git a/MdeModulePkg/Bus/Pci/SataControllerDxe/SataController.c b/MdeModulePkg/Bus/Pci/SataControllerDxe/SataController.c
index ab06e2833c..bd7768c0cd 100644
--- a/MdeModulePkg/Bus/Pci/SataControllerDxe/SataController.c
+++ b/MdeModulePkg/Bus/Pci/SataControllerDxe/SataController.c
@@ -8,6 +8,7 @@
 **/
 
 #include "SataController.h"
+#include <Library/PciLib.h> 
 
 ///
 /// EFI_DRIVER_BINDING_PROTOCOL instance
@@ -243,6 +244,8 @@ CalculateBestUdmaMode (
   @retval other         Some error occurs when executing this entry point.
 
 **/
+
+__attribute__((noinline))
 EFI_STATUS
 EFIAPI
 InitializeSataControllerDriver (
@@ -268,6 +271,49 @@ InitializeSataControllerDriver (
   return Status;
 }
 
+/**
+  There seems to be a bug in the QEMU where the PCI(0x2,0x0), aka VGA
+  for Q35, reports being a SATA controller. We detect the case and
+  skip such bogus sata controller init.
+
+  @retval TRUE  If the platform is identified as QEMU Q35.
+  @retval FALSE Otherwise.
+**/
+
+#define QEMU_Q35_HOST_BRIDGE_VENDOR_ID  0x8086
+#define QEMU_Q35_HOST_BRIDGE_DEVICE_ID  0x29C0
+
+BOOLEAN
+IsQemuQ35Machine (
+  VOID
+  )
+{
+  static BOOLEAN IsQ35          = FALSE;
+  static BOOLEAN AlreadyChecked = FALSE;
+  UINT16         VendorId;
+  UINT16         DeviceId;
+
+  if (AlreadyChecked) {
+    return IsQ35;
+  }
+
+  // Read Vendor ID and Device ID of the Host Bridge at 00:00.0
+  VendorId = PciRead16 (PCI_LIB_ADDRESS (0, 0, 0, PCI_VENDOR_ID_OFFSET));
+  DeviceId = PciRead16 (PCI_LIB_ADDRESS (0, 0, 0, PCI_DEVICE_ID_OFFSET));
+
+  DEBUG ((EFI_D_INFO, "Host Bridge VID:0x%04X, DID:0x%04X\n", VendorId, DeviceId));
+
+  if ((VendorId == QEMU_Q35_HOST_BRIDGE_VENDOR_ID) && (DeviceId == QEMU_Q35_HOST_BRIDGE_DEVICE_ID)) {
+    IsQ35 = TRUE;
+    DEBUG ((EFI_D_INFO, "Detected QEMU Q35\n"));
+  } else {
+    IsQ35 = FALSE;
+  }
+
+  AlreadyChecked = TRUE;
+  return IsQ35;
+}
+
 /**
   Supported function of Driver Binding protocol for this driver.
   Test to see if this driver supports ControllerHandle.
@@ -293,6 +339,7 @@ SataControllerSupported (
   EFI_STATUS            Status;
   EFI_PCI_IO_PROTOCOL   *PciIo;
   PCI_TYPE00            PciData;
+  UINTN                 Segment, Bus, Device, Function;
 
   //
   // Attempt to open PCI I/O Protocol
@@ -324,10 +371,20 @@ SataControllerSupported (
     return EFI_UNSUPPORTED;
   }
 
-  if (IS_PCI_IDE (&PciData) || IS_PCI_SATADPA (&PciData)) {
-    return EFI_SUCCESS;
+  if (IsQemuQ35Machine) {
+    Status = PciIo->GetLocation(PciIo, &Segment, &Bus, &Device, &Function);
+    if (!EFI_ERROR(Status)) {
+      DEBUG((EFI_D_ERROR, "SataSupported: PCI Location Seg:%d Bus:%d Dev:%d Func:%d\n", Segment, Bus, Device, Function));
+      if (!(Bus == 0x00 && Device == 0x1F && Function == 0x02)) {
+          DEBUG((EFI_D_ERROR, "SataSupported: QEMU WORKAROUND: not the primary AHCI controller (00:1f.2). Skipping.\n"));
+          return EFI_UNSUPPORTED;
+      }
+    }
   }
 
+  if (IS_PCI_IDE (&PciData) || IS_PCI_SATADPA (&PciData)) {
+	  return EFI_SUCCESS;
+  }
   return EFI_UNSUPPORTED;
 }
 
-- 
2.34.1

