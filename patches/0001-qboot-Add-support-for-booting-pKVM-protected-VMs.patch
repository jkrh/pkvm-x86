From 96e9b6d46679a841cedaccdfaf9e00671997b3ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Markku=20Ahvenj=C3=A4rvi?= <mankku@gmail.com>
Date: Fri, 12 Dec 2025 09:51:37 +0200
Subject: [PATCH] Add support for booting pKVM protected VMs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Unlike normal VMs, the host VMM cannot access the memory of a protected
VM unless the page is explicitly shared with the host. This patch
enables fw_cfg communication via a bounce buffer that is shared with the
host. Also the page holding the DMA descriptor is shared with the host.

Signed-off-by: Markku Ahvenj√§rvi <mankku@gmail.com>
---
 cc_platform.c         | 100 +++++++++++++++++++++
 fw_cfg.c              |  70 ++++++++++++---
 hwsetup.c             |  16 +++-
 include/cc_platform.h |  17 ++++
 include/fw_cfg.h      |   6 ++
 include/pkvm.h        | 196 ++++++++++++++++++++++++++++++++++++++++++
 main.c                |   2 +
 meson.build           |   1 +
 8 files changed, 391 insertions(+), 17 deletions(-)
 create mode 100644 cc_platform.c
 create mode 100644 include/cc_platform.h
 create mode 100644 include/pkvm.h

diff --git a/cc_platform.c b/cc_platform.c
new file mode 100644
index 000000000000..273fd899a7cc
--- /dev/null
+++ b/cc_platform.c
@@ -0,0 +1,100 @@
+#include "cc_platform.h"
+#include "stddef.h"
+#include "stdint.h"
+#include "fw_cfg.h"
+#include "pkvm.h"
+
+#define FW_CFG_DMA_DESCRIPTOR_PAGE	(0x80000)
+#define FW_CFG_DMA_BUF_PAGE			(FW_CFG_DMA_DESCRIPTOR_PAGE + PAGE_SIZE)
+#define FW_CFG_DMA_BUF_SIZE			(PAGE_SIZE)
+
+static volatile enum cc_platform cc_platform = CC_PLATFORM_NONE;
+
+int cc_platform_detect(void)
+{
+	if (pkvm_detect()) {
+		return CC_PLATFORM_PKVM;
+	}
+	return CC_PLATFORM_NONE;
+}
+
+int cc_platform_setup(void)
+{
+	cc_platform = cc_platform_detect();
+
+	return 0;
+}
+
+static int cc_platform_fw_cfg_check_version(int version)
+{
+	return (version & FW_CFG_VERSION_DMA) ? 0 : -1;
+}
+
+int cc_platform_fw_cfg_setup(int version)
+{
+	int ret = 0;
+
+	switch (cc_platform) {
+	case CC_PLATFORM_PKVM:
+		ret = cc_platform_fw_cfg_check_version(version);
+		if (ret) {
+			break;
+		}
+
+		ret = pkvm_share_mem((void *) FW_CFG_DMA_DESCRIPTOR_PAGE, PAGE_SIZE);
+		if (ret) {
+			break;
+		}
+
+		ret = pkvm_share_mem((void *) FW_CFG_DMA_BUF_PAGE, FW_CFG_DMA_BUF_SIZE);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+int cc_platform_fw_cfg_cleanup(void)
+{
+	int ret = 0;
+
+	switch (cc_platform) {
+	case CC_PLATFORM_PKVM:
+		ret = pkvm_unshare_mem((void *) FW_CFG_DMA_DESCRIPTOR_PAGE, PAGE_SIZE);
+		if (ret) {
+			break;
+		}
+
+		ret = pkvm_unshare_mem((void *) FW_CFG_DMA_BUF_PAGE, FW_CFG_DMA_BUF_SIZE);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+struct fw_cfg_dma_descriptor *cc_platform_fw_cfg_dma_desc(void)
+{
+	return (struct fw_cfg_dma_descriptor *) FW_CFG_DMA_DESCRIPTOR_PAGE;
+}
+
+void *cc_platform_fw_cfg_dma_buf(void *buf)
+{
+	if (cc_platform == CC_PLATFORM_NONE) {
+		return buf;
+	}
+
+	return (void *) FW_CFG_DMA_BUF_PAGE;
+}
+
+int cc_platform_fw_cfg_dma_transfer_size(int len)
+{
+	if (cc_platform == CC_PLATFORM_NONE) {
+		return len;
+	}
+
+	return FW_CFG_DMA_BUF_SIZE;
+}
+
diff --git a/fw_cfg.c b/fw_cfg.c
index f3d9605c469c..4e378bb78f24 100644
--- a/fw_cfg.c
+++ b/fw_cfg.c
@@ -10,6 +10,8 @@
 #include "multiboot.h"
 #include "benchmark.h"
 #include "start_info.h"
+#include "cc_platform.h"
+#include "string.h"
 
 extern struct hvm_start_info start_info;
 
@@ -31,6 +33,10 @@ void fw_cfg_setup(void)
 	fw_cfg_select(FW_CFG_ID);
 	version = fw_cfg_readl_le();
 
+	if (cc_platform_fw_cfg_setup(version)) {
+		panic();
+	}
+
 	fw_cfg_select(FW_CFG_FILE_DIR);
 	n = fw_cfg_readl_be();
 	filecnt = n;
@@ -88,25 +94,57 @@ void fw_cfg_read_file(int id, void *buf, int len)
 	fw_cfg_read_entry(files[id].select, buf, len);
 }
 
-struct fw_cfg_dma_descriptor {
-	uint32_t control;
-	uint32_t length;
-	uint64_t address;
-} __attribute__((packed));
+struct fw_cfg_dma_descriptor dma_desc;
+
+static struct fw_cfg_dma_descriptor *fw_cfg_dma_desc(void)
+{
+	struct fw_cfg_dma_descriptor *desc = cc_platform_fw_cfg_dma_desc();
+	if (desc) {
+		return desc;
+	}
+
+	return &dma_desc;
+}
+
+static void *fw_cfg_dma_buf(void *buf)
+{
+	return cc_platform_fw_cfg_dma_buf(buf);
+}
+
+static int fw_cfg_dma_transfer_size(int len)
+{
+	return cc_platform_fw_cfg_dma_transfer_size(len);
+}
 
 void fw_cfg_dma(int control, void *buf, int len)
 {
-	volatile struct fw_cfg_dma_descriptor dma;
+	volatile struct fw_cfg_dma_descriptor *dma = fw_cfg_dma_desc();
+	void *dma_buf = fw_cfg_dma_buf(buf);
+
+	uint32_t max_transfer_size = fw_cfg_dma_transfer_size(len);
+	uint32_t transfer_size;
 	uint32_t dma_desc_addr;
 
-	dma.control = bswap32(control);
-	dma.length = bswap32(len);
-	dma.address = bswap64((uintptr_t)buf);
+	for (unsigned transferred = 0; transferred < len; transferred += max_transfer_size) {
+		transfer_size = len - transferred;
+		transfer_size = (transfer_size < max_transfer_size) ? transfer_size : max_transfer_size;
+
+		dma->control = bswap32(control);
+		dma->length = bswap32(transfer_size);
+		dma->address = bswap64((uintptr_t)dma_buf);
+
+		dma_desc_addr = (uint32_t)dma;
+		outl(FW_CFG_DMA_ADDR_LOW, bswap32(dma_desc_addr));
+		while (bswap32(dma->control) & ~FW_CFG_DMA_CTL_ERROR) {
+			asm("");
+		}
+
+		if (dma_buf != buf && control & FW_CFG_DMA_CTL_READ) {
+			memcpy(buf + transferred, dma_buf, transfer_size);
+		}
 
-	dma_desc_addr = (uint32_t)&dma;
-	outl(FW_CFG_DMA_ADDR_LOW, bswap32(dma_desc_addr));
-	while (bswap32(dma.control) & ~FW_CFG_DMA_CTL_ERROR) {
-		asm("");
+		/* Clear select to continue access */
+		control &= ~FW_CFG_DMA_CTL_SELECT;
 	}
 }
 
@@ -175,6 +213,8 @@ static void boot_multiboot_from_fw_cfg(void)
 		mb->mmap_length += sizeof(*mbmem);
 	}
 
+	cc_platform_fw_cfg_cleanup();
+
 #ifdef BENCHMARK_HACK
 	/* Exit just before getting to vmlinuz, so that it is easy
 	 * to time/profile the firmware.
@@ -254,6 +294,8 @@ static void boot_pvh_from_fw_cfg(void)
 	fw_cfg_select(FW_CFG_KERNEL_ENTRY);
 	kernel_entry = (void *) fw_cfg_readl_le();
 
+	cc_platform_fw_cfg_cleanup();
+
 #ifdef BENCHMARK_HACK
 	/* Exit just before jumping to vmlinux, so that it is easy
 	 * to time/profile the firmware.
@@ -314,5 +356,7 @@ void boot_from_fwcfg(void)
 		fw_cfg_read_entry(FW_CFG_INITRD_DATA, args.initrd_addr, args.initrd_size);
 	}
 
+	cc_platform_fw_cfg_cleanup();
+
 	boot_bzimage(&args);
 }
diff --git a/hwsetup.c b/hwsetup.c
index 250213e5c189..022e232eeb29 100644
--- a/hwsetup.c
+++ b/hwsetup.c
@@ -2,6 +2,7 @@
 #include "ioport.h"
 #include "pci.h"
 #include "string.h"
+#include "cc_platform.h"
 
 // NOTE: this runs from ROM at 0xFFFF0000, so it is not possible to use any
 // static data.
@@ -116,11 +117,18 @@ bool setup_hw(void)
 		return false;
 	}
 
-	// Make ram from 0xc0000-0xf0000 read-write
-	rom_check_value = rom_check;
-	rom_check = rom_check_value + 1;
-	if (rom_check == rom_check_value)
+	if (cc_platform_detect() == CC_PLATFORM_NONE) {
+		// Make ram from 0xc0000-0xf0000 read-write
+		rom_check_value = rom_check;
+		rom_check = rom_check_value + 1;
+
+		if (rom_check == rom_check_value) {
+			setup_pam(bdf, pambase);
+		}
+	} else {
+		// Just skip the foreplay and setup PAM
 		setup_pam(bdf, pambase);
+	}
 
 	// Shadow BIOS; we're still running from 0xffff0000
 	memcpy(&stext, bios_start, &edata - &stext);
diff --git a/include/cc_platform.h b/include/cc_platform.h
new file mode 100644
index 000000000000..0c16495b5c32
--- /dev/null
+++ b/include/cc_platform.h
@@ -0,0 +1,17 @@
+#ifndef BIOS_CC_PLATFORM_H
+#define BIOS_CC_PLATFORM_H
+
+enum cc_platform {
+	CC_PLATFORM_NONE,
+	CC_PLATFORM_PKVM,
+};
+
+int cc_platform_detect(void);
+int cc_platform_setup(void);
+int cc_platform_fw_cfg_setup(int version);
+int cc_platform_fw_cfg_cleanup(void);
+struct fw_cfg_dma_descriptor *cc_platform_fw_cfg_dma_desc(void);
+void *cc_platform_fw_cfg_dma_buf(void *buf);
+int cc_platform_fw_cfg_dma_transfer_size(int len);
+
+#endif /* BIOS_PLATFORM_H */
diff --git a/include/fw_cfg.h b/include/fw_cfg.h
index 1ddfc1f7ef61..a252bc5f59aa 100644
--- a/include/fw_cfg.h
+++ b/include/fw_cfg.h
@@ -49,6 +49,12 @@
 #define FW_CFG_DMA_ADDR_HIGH          0x514
 #define FW_CFG_DMA_ADDR_LOW           0x518
 
+struct fw_cfg_dma_descriptor {
+	uint32_t control;
+	uint32_t length;
+	uint64_t address;
+} __attribute__((packed));
+
 #include "ioport.h"
 
 static inline void fw_cfg_select(uint16_t f)
diff --git a/include/pkvm.h b/include/pkvm.h
new file mode 100644
index 000000000000..4830910eb0fa
--- /dev/null
+++ b/include/pkvm.h
@@ -0,0 +1,196 @@
+#ifndef BIOS_PKVM_X86_H
+#define BIOS_PKVM_X86_H
+
+#include "bios.h"
+
+#define ALIGN(x, a)		__ALIGN((x), (a))
+#define ALIGN_DOWN(x, a)	__ALIGN((x) - ((a) - 1), (a))
+#define __ALIGN(x, a)		__ALIGN_MASK(x, (__typeof__(x))(a) - 1)
+#define __ALIGN_MASK(x, mask)	(((x) + (mask)) & ~(mask))
+
+#define PAGE_SIZE (4096)
+#define ALIGN_PAGE(x) ALIGN_DOWN((x), PAGE_SIZE)
+
+/* Guest hypercalls */
+#define KVM_HC_PKVM_OP                  20
+#define PKVM_GHC_NUM(x) (x + KVM_HC_PKVM_OP)
+
+#define PKVM_GHC_SHARE_MEM              PKVM_GHC_NUM(1)
+#define PKVM_GHC_UNSHARE_MEM            PKVM_GHC_NUM(2)
+#define PKVM_GHC_IOREAD                 PKVM_GHC_NUM(3)
+#define PKVM_GHC_IOWRITE                PKVM_GHC_NUM(4)
+#define PKVM_GHC_GET_VE_INFO            PKVM_GHC_NUM(5)
+
+static inline long hypercall1(unsigned int nr, unsigned long p1)
+{
+       long ret;
+
+       asm volatile("vmcall"
+                    : "=a"(ret)
+                    : "a"(nr), "b"(p1)
+                    : "memory");
+       return ret;
+}
+
+static inline long hypercall2(unsigned int nr,
+			      unsigned long p1,
+			      unsigned long p2)
+{
+       long ret;
+
+       asm volatile("vmcall"
+                    : "=a"(ret)
+                    : "a"(nr), "b"(p1), "c"(p2)
+                    : "memory");
+       return ret;
+}
+
+static inline void touch_pages(unsigned long addr, unsigned long size)
+{
+	volatile unsigned char *p = (unsigned char *) ALIGN_PAGE(addr);
+	unsigned char dummy;
+
+	while ((uintptr_t) p < (uintptr_t) (addr + size)) {
+		dummy = *p;
+		(void) dummy;
+		p += PAGE_SIZE;
+	}
+}
+
+static inline long _pkvm_share_mem(unsigned long addr, unsigned long size)
+{
+	touch_pages(addr, size);
+	return hypercall2(PKVM_GHC_SHARE_MEM, addr, size);
+}
+
+static inline long _pkvm_unshare_mem(unsigned long addr, unsigned long size)
+{
+	return hypercall2(PKVM_GHC_UNSHARE_MEM, addr, size);
+}
+
+static inline int pkvm_share_mem(void *buf, unsigned long size)
+{
+	/* align down to page boundary */
+	uintptr_t buf_aligned = ALIGN_PAGE((uintptr_t) buf);
+	/* align up to page boundary */
+	unsigned long size_aligned = ALIGN(size + ((uintptr_t) buf - buf_aligned), PAGE_SIZE);
+
+	return _pkvm_share_mem((unsigned long) buf_aligned, size_aligned);
+}
+
+static inline int pkvm_unshare_mem(void *buf, unsigned long size)
+{
+	/* align down to page boundary */
+	unsigned long buf_aligned = ALIGN_PAGE((uintptr_t) buf);
+	/* round up to page boundary */
+	unsigned long size_aligned = ALIGN(size + ((uintptr_t) buf - buf_aligned), PAGE_SIZE);
+
+	return _pkvm_unshare_mem(buf_aligned, size_aligned);
+}
+
+static inline bool pkvm_buffers_intersect(uintptr_t base_a, unsigned long size_a,
+					  uintptr_t base_b, unsigned long size_b)
+{
+	return base_a < base_b + size_b && base_b < base_a + size_a;
+}
+
+// A variant that avoids sharing reserved region
+static inline long pkvm_share_mem_skip_reserved(unsigned long addr, unsigned long size)
+{
+	if (pkvm_buffers_intersect(addr, size,
+				   (uintptr_t) &stext, &edata - &stext)) {
+		return -1;
+	}
+
+	return _pkvm_share_mem(addr, size);
+}
+
+// A variant that avoids unsharing reserved region
+static inline long pkvm_unshare_mem_skip_reserved(unsigned long addr, unsigned long size)
+{
+	if (pkvm_buffers_intersect(addr, size,
+				   (uintptr_t) &stext, &edata - &stext)) {
+		return -1;
+	}
+
+	return _pkvm_unshare_mem(addr, size);
+}
+
+static inline int pkvm_share_pages(void *buf, unsigned long size)
+{
+	/* align down to page boundary */
+	unsigned long cur = ALIGN_PAGE((uintptr_t) buf);
+	/* align up to the page boundary */
+	unsigned long end = ALIGN((uintptr_t) buf + size, PAGE_SIZE);
+
+	/* number of failed shares */
+	int failed = 0;
+
+	/* share one page at a time */
+	while (cur < end) {
+		if (pkvm_share_mem_skip_reserved((unsigned long) cur, PAGE_SIZE)) {
+			failed++;
+		}
+		cur += PAGE_SIZE;
+	}
+
+	return failed;
+}
+
+static inline int pkvm_unshare_pages(void *buf, unsigned long size)
+{
+	/* align down to page boundary */
+	unsigned long cur = ALIGN_PAGE((uintptr_t) buf);
+	/* align up to the page boundary */
+	unsigned long end = ALIGN((uintptr_t) buf + size, PAGE_SIZE);
+
+	/* number of failed shares */
+	int failed = 0;
+
+	/* share one page at a time */
+	while (cur < end) {
+		if (pkvm_unshare_mem_skip_reserved((unsigned long) cur, PAGE_SIZE)) {
+			failed++;
+		}
+		cur += PAGE_SIZE;
+	}
+
+	return failed;
+}
+
+static inline int pkvm_share_buffer(void *buf, unsigned long size)
+{
+	return pkvm_share_pages(buf, size);
+}
+
+static inline int pkvm_unshare_buffer(void *buf, unsigned long size)
+{
+	return pkvm_unshare_pages(buf, size);
+}
+
+static inline bool pkvm_detect(void)
+{
+	uint32_t eax, signature[3];
+
+	asm("cpuid"
+	    : "=a" (eax),
+	      "=b" (signature[0]),
+	      "=c" (signature[1]),
+	      "=d" (signature[2])
+	    : "0" (0x40000000), "2" (0));
+
+	/* We need to jump through some hoops here. Some memory regions are
+	 * not accessible when this is called, so we cannot directly memcmp
+	 * the signature with the string "PKVMPKVMPKVM".
+	 *
+	 * "PKVM" = 0x4d564b50
+	 */
+	for (int i = 0; i < ARRAY_SIZE(signature); i++) {
+		if (signature[i] != 0x4d564b50)
+			return false;
+	}
+
+	return true;
+}
+
+#endif /* BIOS_PKVM_X86 */
diff --git a/main.c b/main.c
index afa2200cb0f4..64e5f27072ec 100644
--- a/main.c
+++ b/main.c
@@ -8,6 +8,7 @@
 #include "pci.h"
 #include "benchmark.h"
 #include "smbios.h"
+#include "cc_platform.h"
 
 static void set_realmode_int(int vec, void *p)
 {
@@ -94,6 +95,7 @@ int __attribute__ ((section (".text.startup"))) main(void)
 	if (have_pci) {
 		setup_pci();
 	}
+	cc_platform_setup();
 	setup_idt();
 	fw_cfg_setup();
 	extract_acpi();
diff --git a/meson.build b/meson.build
index d060f756e136..35c1bec72af9 100644
--- a/meson.build
+++ b/meson.build
@@ -23,6 +23,7 @@ link_args += cc.get_supported_link_arguments(['-no-pie'])
 elf = executable(
   'bios.bin.elf',
   files(
+    'cc_platform.c',
     'code16.c',
     'code32seg.c',
     'cstart.S',
-- 
2.49.0

